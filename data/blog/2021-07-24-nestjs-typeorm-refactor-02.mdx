---
title: 'Nest.js TypeORM ë¦¬íŒ©í„°ë§ (QueryBuilder)'
date: '2021-07-24'
tags: ['nest.js', 'typeorm', 'refactoring', 'ddd']
draft: false
---

![](https://velog.velcdn.com/images/loakick/post/404e5730-0cc7-46be-9851-e6649a487a30/Nestjs.png)

ì§€ë‚œë²ˆì—ëŠ” TypeORM Repositoryë¥¼ DDDí•˜ê²Œ ë„ë©”ì¸ Aggregate ë²”ìœ„ì™€ ì¼ì¹˜ì‹œí‚¤ëŠ” ë²•ì— ì‚´í´ë³´ì•˜ìŠµë‹ˆë‹¤.

ì´ë²ˆì—ëŠ” `TypeORM`ì—ì„œ ìì£¼ ì´ìš©í•˜ëŠ” `QueryBuilder`ì˜ ì½”ë“œëŸ‰ì„ ì¤„ì´ëŠ” ë²•ì— ëŒ€í•´ ì‚´í´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.

> ğŸš§ ì´ë²ˆ í¬ìŠ¤íŠ¸ëŠ” ì½”ë“œê°€ êµ‰ì¥íˆ ë§ìŠµë‹ˆë‹¤! ì—¬ìœ ë¡œìš´ ë§ˆìŒì„ ê°€ì§€ê³  ë´ì£¼ì„¸ìš”.

## QueryBuilder ì¬ì‚¬ìš©ì„± ë†’ì´ê¸°

ì„œë¹„ìŠ¤ë¥¼ ë§Œë“¤ë©´ì„œ ì¡°íšŒê°€ í•„ìš”í•œ ì¿¼ë¦¬ëŠ” ëª¨ë‘ `TypeORM`ì˜ `QueryBuilder` íŒ¨í„´ì„ ì´ìš©í•˜ì—¬ ë§Œë“¤ê³  ìˆìŠµë‹ˆë‹¤. `QueryBuilder`ê°€ `TypeORM`ì˜ `findOne`ê³¼ ê°™ì€ í•¨ìˆ˜ë³´ë‹¤ ë” ì„¸ë°€í•˜ê²Œ`(ì¡°ì¸ëœ í…Œì´ë¸” where, order, having, groupë“±)` ì¿¼ë¦¬ë¥¼ ì¡°ì •í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì…ë‹ˆë‹¤.

```typescript
// user.service.ts
import { Injectable } from '@nestjs/common'
import { UserRepository } from './user.repository'

@Injectable()
export class UserService {
  constructor(private readonly userRepository: UserRepository) {}

  public async findOneByUserId(userId: number) {
    return this.userRepository.findOneByUserId(userId)
  }

  public async findOneByEmail(email: string) {
    return this.userRepository.findOneByEmail(email)
  }

  public async findOneByNickname(nickname: string) {
    return this.userRepository.findOneByNickname(nickname)
  }
}
```

```typescript
// user.repository.ts
import { AbstractRepository, EntityRepository } from 'typeorm'
import { User } from './user.entity'

@EntityRepository(User)
export class UserRepository extends AbstractRepository<User> {
  public async findOneByUserId(userId: number) {
    const qb = this.repository
      .createQueryBuilder('User')
      .leftJoinAndSelect('User.userAuth', 'userAuth')
      .leftJoinAndSelect('User.userProfile', 'userProfile')

    qb.andWhere('User.id = :id', { id: userId })

    return qb.getOne()
  }

  public async findOneByEmail(email: string) {
    const qb = this.repository
      .createQueryBuilder('User')
      .leftJoinAndSelect('User.userAuth', 'userAuth')
      .leftJoinAndSelect('User.userProfile', 'userProfile')

    qb.andWhere('User.email = :email', { email })

    return qb.getOne()
  }

  public async findOneByNickname(nickname: string) {
    const qb = this.repository
      .createQueryBuilder('User')
      .leftJoinAndSelect('User.userAuth', 'userAuth')
      .leftJoinAndSelect('User.userProfile', 'userProfile')

    qb.andWhere('User.nickname = :nickname', { nickname })

    return qb.getOne()
  }
}
```

í•˜ì§€ë§Œ ë¹„ì¦ˆë‹ˆìŠ¤ ì¡°íšŒ ë¡œì§ì´ ë§ì•„ì§ˆ ìˆ˜ë¡, `QueryBuilder` í•¨ìˆ˜ë¥¼ ë°˜ë³µí•´ì„œ ì‚¬ìš©í•˜ëŠ” ê²½ìš°ê°€ ë§ì•„ì¡ŒìŠµë‹ˆë‹¤. ë¬¸ì œëŠ” í¬ê²Œ 3ê°€ì§€ ê²½ìš°ì˜€ìŠµë‹ˆë‹¤.

- ë„ˆë¬´ ë§ì´ ë°˜ë³µ.. ë˜ ë°˜ë³µ
- Or ì—°ì‚°ì€ ì–´ë–»ê²Œ í•˜ì§€?
- FindOperatorë¡œ ì—°ì‚°ì ë²”ìœ„ ë„“íˆê¸°

## ë„ˆë¬´ ë§ì´ ë°˜ë³µ.. ë˜ ë°˜ë³µ

ìœ„ì˜ ì˜ˆì œì™€ ê°™ì´ `Service`ì—ì„œ ì¡°íšŒì˜ ë‹¨ìœ„ê°€ ë§ì•„ì§ˆ ë•Œë§ˆë‹¤ `Repository`ì—ë„ ê°™ì´ ëŠ˜ì–´ë‚˜ëŠ” ë¬¸ì œê°€ ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ë‹¤ìŒê³¼ ê°™ì´ `Repository`ì˜ ì¡°íšŒ ë©”ì†Œë“œë¥¼ ë¬¶ì–´ì£¼ì–´ í•´ê²°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```typescript
// user.service.ts
import { Injectable } from '@nestjs/common'
import { UserRepository } from './user.repository'

@Injectable()
export class UserService {
  constructor(private readonly userRepository: UserRepository) {}

  public async findOneByUserId(userId: number) {
    return this.userRepository.findOne({ id: userId })
  }

  public async findOneByEmail(email: string) {
    return this.userRepository.findOne({ email })
  }

  public async findOneByNickname(nickname: string) {
    return this.userRepository.findOne({ nickname })
  }
}
```

```typescript
// user.repository.ts
import { AbstractRepository, EntityRepository } from 'typeorm'
import { User } from './user.entity'

export interface UserFindOneOptions {
  id?: number
  email?: string
  nickname?: string
}

@EntityRepository(User)
export class UserRepository extends AbstractRepository<User> {
  public async findOne({ id, email, nickname }: UserFindOneOptions = {}) {
    const qb = this.repository
      .createQueryBuilder('User')
      .leftJoinAndSelect('User.userAuth', 'userAuth')
      .leftJoinAndSelect('User.userProfile', 'userProfile')

    if (id) qb.andWhere('User.id = :id', { id })
    if (email) qb.andWhere('User.email = :email', { email })
    if (nickname) qb.andWhere('User.nickname = :nickname', { nickname })

    return qb.getOne()
  }
}
```

ì—¬ê¸°ì„œ ì£¼ì˜í•´ì•¼í•  ê²ƒì´ ìˆìŠµë‹ˆë‹¤. `Service`ì—ì„œ `this.userRepository.findOne()` ì™€ ê°™ì´ íŒŒë¼ë¯¸í„°ë¥¼ ë„˜ê¸°ì§€ ì•Šê³  í˜¸ì¶œí•˜ë©´, í•´ë‹¹ í…Œì´ë¸”ì— ì¡´ì¬í•˜ëŠ” ê°€ì¥ ì²«ë²ˆì§¸ ê°ì²´ê°€ ê°€ì ¸ì™€ì§‘ë‹ˆë‹¤. Queryë¡œ ë³€í™˜í•˜ë©´ `SELECT * FROM USER LIMIT 1` í•˜ëŠ” ê²ƒê³¼ ë§ˆì°¬ê°€ì§€ë‹ˆê¹Œìš”! ë”°ë¼ì„œ ë¹ˆ íŒŒë¼ë¯¸í„°ë¥¼ ë„˜ê¸¸ ê²½ìš°, `null`ê°’ì„ ë°˜í™˜í•˜ëŠ” ì˜ˆì™¸ì²˜ë¦¬ê°€ í•„ìš”í•©ë‹ˆë‹¤.

```typescript
// user.repository.ts
import { pickBy, isNil, negate } from 'lodash'

// ê°ì²´ì˜ null, undefined ê°’ì¸ í‚¤ë“¤ì„ ì§€ì›Œì¤ë‹ˆë‹¤.
// ìì„¸í•œ ì›ë¦¬ëŠ” lodashë¥¼ ì°¸ê³ í•˜ì„¸ìš”.
export const removeNilFromObject = (object: object) => {
  return pickBy(object, negate(isNil))
}

@EntityRepository(User)
export class UserRepository extends AbstractRepository<User> {
  public async findOne(options: UserFindOneOptions = {}) {
    // ë¹ˆ ê°ì²´ì¼ ê²½ìš° nullì„ ë°˜í™˜í•©ë‹ˆë‹¤.
    if (Object.keys(removeNilFromObject(options)).length === 0) return null
    const { id, email, nickname } = options

    // ...

    return qb.getOne()
  }
}
```

## Or ì—°ì‚°ì€ ì–´ë–»ê²Œ í•˜ì§€?

ê°™ì€ ë°©ë²•ìœ¼ë¡œ ë§Œë“  `findAll` í•¨ìˆ˜ë¥¼ ë³´ê² ìŠµë‹ˆë‹¤.

```typescript
// user.repository.ts
import { AbstractRepository, EntityRepository } from 'typeorm'
import { User } from './user.entity'

export interface UserFindAllWhereOptions {
  id?: number
  email?: string
  nickname?: string
}

export interface UserFindAllOptions {
  where?: UserFindAllWhereOptions
  skip?: number
  take?: number
}

@EntityRepository(User)
export class UserRepository extends AbstractRepository<User> {
  // ...

  // í•œë²ˆì— ë§ì€ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ëŠ” ê²ƒì„ ë°©ì§€í•˜ê¸° ìœ„í•´ skip, takeë¡œ í˜ì´ì§€ë„¤ì´íŒ… í•©ë‹ˆë‹¤.
  public async findAll(options: UserFindAllOptions = {}) {
    const { where, skip, take } = options

    const qb = this.repository
      .createQueryBuilder('User')
      .leftJoinAndSelect('User.userAuth', 'userAuth')
      .leftJoinAndSelect('User.userProfile', 'userProfile')

    if (where) {
      const { id, email, nickname } = where
      if (id) qb.andWhere('User.id = :id', { id })
      if (email) qb.andWhere('User.email = :email', { email })
      if (nickname) qb.andWhere('User.nickname = :nickname', { nickname })
    }

    qb.skip(skip ?? 0)
    qb.skip(take ?? 20)

    const [items, total] = await qb.getManyAndCount()

    return { items, total }
  }
}
```

í˜„ì¬ ë‹¨ê³„ì—ì„œ `findAll` í•¨ìˆ˜ëŠ” `AND` ì—°ì‚°ë§Œ ê°€ëŠ¥í•©ë‹ˆë‹¤. `ë‹‰ë„¤ì„ì´ â€˜alfredâ€™ ì´ê±°ë‚˜, idê°€ 5ì¸ User`ë¥¼ ê°€ì ¸ì˜¤ì§€ ëª»í•˜ì§€ìš”. OR ì—°ì‚°ì´ ê°€ëŠ¥í•˜ê²Œ í•˜ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼í• ê¹Œìš”?

ì—¬ê¸°ì„œë¶€í„° ëŒ€ëŒ€ì ì¸ ë¦¬íŒ©í„°ë§ì´ í•„ìš”í•©ë‹ˆë‹¤. where ì— ê°ì²´ê°€ ë“¤ì–´ê°€ë©´ Andì´ê³ , ë°°ì—´ì„ ë„£ìœ¼ë©´ Orë¼ê³  ì¸ì‹í•˜ê²Œ í•˜ë©´ ì–´ë–¨ê¹Œìš” ?

> **IDê°€ 5ì´ê³ , Nicknameì´ 'alfred'ì¸ ìœ ì €** > `this.userRepository.findAll({ where: {id: 5, nickname: 'alfred'} })` > **IDê°€ 5ì´ê±°ë‚˜, Nicknameì´ 'alfred'ì¸ ìœ ì €** > `this.userRepository.findAll({ where: [{id: 5},{nickname: 'alfred'}] })`

ë¨¼ì € `UserFindAllOptions` íƒ€ì…ì„ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•©ë‹ˆë‹¤.

```typescript
export interface UserFindAllWhereOptions {
  id?: number
  email?: string
  nickname?: string
}
export interface UserFindAllOptions {
  where?: UserFindAllWhereOptions | UserFindAllWhereOptions[]
  skip?: number
  take?: number
}
```

ê·¸ë¦¬ê³  `UserRepository` `findAll` í•¨ìˆ˜ë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ì •ì˜í•©ë‹ˆë‹¤.

```typescript
// user.repository.ts
import { AbstractRepository, Brackets, EntityRepository } from 'typeorm'
import { User } from './user.entity'

export interface UserFindAllWhereOptions {
  id?: number
  email?: string
  nickname?: string
}

export interface UserFindAllOptions {
  where?: UserFindAllWhereOptions | UserFindAllWhereOptions[]

  skip?: number
  take?: number
}

@EntityRepository(User)
export class UserRepository extends AbstractRepository<User> {
  // ...

  public async findAll(options: UserFindAllOptions = {}) {
    const { where, skip, take } = options

    const qb = this.repository
      .createQueryBuilder('User')
      .leftJoinAndSelect('User.userAuth', 'userAuth')
      .leftJoinAndSelect('User.userProfile', 'userProfile')

    if (where) {
      // ê°€ì¥ ìƒìœ„ì— AND ì—°ì‚°ìœ¼ë¡œ ê´„í˜¸ë¥¼ ì”Œì›Œì¤˜ì•¼í•œë‹¤: ( (...) OR (...) OR (...) )
      if (Array.isArray(where)) {
        qb.andWhere(
          new Brackets((qb) => {
            // whereì´ ë°°ì—´ì´ë©´ OR ì—°ì‚°: (...) OR (...) OR (...)
            where.forEach((wh) => {
              qb.orWhere(
                // OR ì—°ì‚°
                new Brackets((qb) => {
                  // whereì˜ ë°°ì—´ í•œ ìš”ì†Œë§ˆë‹¤ ê´„í˜¸ë¥¼ ì”Œìš´ë‹¤
                  const { id, email, nickname } = wh
                  if (id) qb.andWhere(`User.id = ${id}`)
                  if (email) qb.andWhere(`User.email = "${email}"`)
                  if (nickname) qb.andWhere(`User.nickname = "${nickname}"`)
                })
              )
            })
          })
        )
      } else {
        const { id, email, nickname } = where
        if (id) qb.andWhere('User.id = :id', { id })
        if (email) qb.andWhere('User.email = :email', { email })
        if (nickname) qb.andWhere('User.nickname = :nickname', { nickname })
      }
    }

    qb.skip(skip ?? 0)
    qb.skip(take ?? 20)

    const [items, total] = await qb.getManyAndCount()

    return { items, total }
  }
}
```

ì•„ì§ ë¶ˆì™„ì „í•œ ë¶€ë¶„ì´ ì¡°ê¸ˆ ìˆì§€ë§Œ, OR ì—°ì‚°ì„ í•  ìˆ˜ ìˆëŠ” ë¼ˆëŒ€ëŠ” ì™„ì„±í–ˆìŠµë‹ˆë‹¤! í•˜ì§€ë§Œ `Repository` í´ë˜ìŠ¤ì˜ ë©ì¹˜ê°€ ë„ˆë¬´ ì»¤ì ¸ë²„ë ¸ìŠµë‹ˆë‹¤. ì¿¼ë¦¬ ë¹Œë”ì˜ ë¡œì§ ì—°ì‚°ì´ ë§ì•„ì¡Œê¸° ë•Œë¬¸ì…ë‹ˆë‹¤. ì´ë¥¼ `QueryApplier` ë¼ëŠ” í´ë˜ìŠ¤ë¥¼ ë”°ë¡œ ë§Œë“¤ì–´ ìˆ˜í–‰í•˜ê²Œ í•˜ë©´ ì–´ë–¨ê¹Œìš”?

ë¨¼ì € ì»¤ìŠ¤í…€ ë ˆí¬ì§€í† ë¦¬ ìƒìœ„ ì¶”ìƒ í´ë˜ìŠ¤ë¥¼ ì •ì˜í•˜ì—¬ ê·¸ ê³³ì—ì„œ `QueryApplier`ë¥¼ í•©ì„±ì‹œí‚¤ê² ìŠµë‹ˆë‹¤. `AbstractEntityRepository` ë¼ëŠ” `class`ë¥¼ ìƒˆë¡œ ë§Œë“­ë‹ˆë‹¤.

```typescript
// entity.repository.ts
import { AbstractRepository, WhereExpression, Brackets, FindOperator } from 'typeorm'

export abstract class AbstractEntityRepository<T> extends AbstractRepository<T> {
  protected readonly queryApplier: EntityQueryApplier

  constructor() {
    super()
    this.queryApplier = new EntityQueryApplier()
  }
}

export interface BuildWhereOptionsFunction<T> {
  ({ filterQuery, where }: { filterQuery: (query: string) => void; where: T }): void
}

export interface ApplyOptions<T> {
  qb: WhereExpression
  where?: T | T[]
  buildWhereOptions: BuildWhereOptionsFunction<T>
}

class EntityQueryApplier {
  public apply<T>({ qb, where, buildWhereOptions }: ApplyOptions<T>) {
    if (!where) return

    if (Array.isArray(where)) {
      qb.andWhere(
        new Brackets((qb) => {
          where.forEach((wh) => {
            qb.orWhere(
              new Brackets((qb) => {
                this.applyBuildOptions({ qb, where: wh, buildWhereOptions })
              })
            )
          })
        })
      )
    } else {
      this.applyBuildOptions({ qb, where, buildWhereOptions })
    }
  }

  private applyBuildOptions<T>({
    qb,
    where,
    buildWhereOptions,
  }: {
    qb: WhereExpression
    where: T
    buildWhereOptions: BuildWhereOptionsFunction<T>
  }) {
    buildWhereOptions({
      where,
      filterQuery: (query: string) => {
        qb.andWhere(query)
      },
    })
  }
}
```

> ìœ„ì™€ ê°™ì´ queryBuilderì˜ where ë¡œì§ì„ ë”°ë¡œ í´ë˜ìŠ¤ë¡œ ë¹¼ëƒ…ë‹ˆë‹¤.

ìœ„ ì¶”ìƒ ë ˆí¬ì§€í† ë¦¬ í´ë˜ìŠ¤ë¥¼ ì´ìš©í•˜ì—¬ `UserRepository`ì˜ `findAll`ì„ ë¦¬íŒ©í„°ë§í•´ë³´ê² ìŠµë‹ˆë‹¤.

```typescript
// user.repository.ts
import { Brackets, EntityRepository } from 'typeorm'
import { AbstractEntityRepository } from './entity.repository.v2'
import { User } from './user.entity'

export interface UserFindAllWhereOptions {
  id?: number
  email?: string
  nickname?: string
}

export interface UserFindAllOptions {
  where?: UserFindAllWhereOptions | UserFindAllWhereOptions[]

  skip?: number
  take?: number
}

@EntityRepository(User)
export class UserRepository extends AbstractEntityRepository<User> {
  // ...

  public async findAll(options: UserFindAllOptions = {}) {
    const { where, skip, take } = options

    const qb = this.repository
      .createQueryBuilder('User')
      .leftJoinAndSelect('User.userAuth', 'userAuth')
      .leftJoinAndSelect('User.userProfile', 'userProfile')

    this.queryApplier.apply({
      qb,
      where,
      buildWhereOptions: ({ filterQuery, where }) => {
        const { id, email, nickname } = where

        filterQuery(`User.id = ${id}`)
        filterQuery(`User.email = "${email}"`) // ë¬¸ìì—´ì€ í° ë”°ì˜´í‘œë¡œ ê°ì‹¸ì¤˜ì•¼ í•©ë‹ˆë‹¤.
        filterQuery(`User.nickname = "${nickname}"`)
      },
    })

    qb.skip(skip ?? 0)
    qb.skip(take ?? 20)

    const [items, total] = await qb.getManyAndCount()

    return { items, total }
  }
}
```

`UserRepository`ëŠ” `AbstractEntityRepository`ë¥¼ ìƒì†ë°›ì•„ ë‹¤ìŒê³¼ ê°™ì´ ì¿¼ë¦¬ `where` ì¡°íšŒ ë¡œì§ì„ `QueryApplier`ë¡œ ìœ„ì„í•©ë‹ˆë‹¤.

ì•ìœ¼ë¡œ ì»¤ìŠ¤í…€ ë ˆí¬ì§€í† ë¦¬ë¥¼ ë§Œë“¤ë•Œë§ˆë‹¤ OR ì¡°íšŒë¥¼ í¬í•¨í•œ ë¡œì§ì„ ê°„ë‹¨í•˜ê²Œ ì¤„ì¼ ìˆ˜ ìˆê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.

## FindOperatorë¡œ ì—°ì‚°ì ë²”ìœ„ ë„“íˆê¸°

TypeORM Repository ê¸°ë³¸ ë‚´ì¥ í•¨ìˆ˜ì¸ `find`, `findOne`ì„ ì´ìš©í•˜ë©´ ì»¬ëŸ¼ ê°’ì— ë‹¤ìŒê³¼ ê°™ì€ `FindOperator` (`In`, `LessThan`, `Like`ë“±)ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

`this.userRepository.find({ where: { id: In([1,2,3,4,5]) } })`

ìš°ë¦¬ê°€ ë§Œë“  `findOne`, `findAll`ì—ë„ ì´ëŸ° `FindOperator`ë¥¼ ì ìš©í•  ìˆ˜ ìˆê²Œ í•´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.

ì‹¤ì œë¡œ ì¿¼ë¦¬ë¥¼ ì ìš©í•˜ëŠ” ë¶€ë¶„ì€ `QueryApplier`ì˜ `applyBuildOptions` í•¨ìˆ˜ ë‚´ë¶€ì˜ `filterQuery` ì…ë‹ˆë‹¤. ê·¸ ê³³ì— `FindOperator` ê°’ì´ ë“¤ì–´ê°ˆ ìˆ˜ ìˆë„ë¡ ìˆ˜ì •í•˜ê² ìŠµë‹ˆë‹¤. ì½”ë“œê°€ ë‹¤ì†Œ ê¸¸ì§€ë§Œ ì—¬ìœ ë¥¼ ê°–ê³  ì½ì–´ë³´ì‹œê¸¸ ë°”ëë‹ˆë‹¤.

```typescript
// entity.repository.ts
import { isNil } from 'lodash'
import { AbstractRepository, WhereExpression, Brackets, FindOperator } from 'typeorm'

export type EntityFindOperator<T> = T | FindOperator<T>

export abstract class AbstractEntityRepository<T> extends AbstractRepository<T> {
  protected readonly queryApplier: EntityQueryApplier

  constructor() {
    super()
    this.queryApplier = new EntityQueryApplier()
  }
}

export interface BuildWhereOptionsFunction<T> {
  ({
    filterQuery,
    where,
  }: {
    filterQuery: (property: string, valueOrOperator: any) => void
    where: T
  }): void
}

export interface ApplyOptions<T> {
  qb: WhereExpression
  where?: T | T[]
  buildWhereOptions: BuildWhereOptionsFunction<T>
}

class EntityQueryApplier {
  public apply<T>({ qb, where, buildWhereOptions }: ApplyOptions<T>) {
    if (!where) return

    if (Array.isArray(where)) {
      qb.andWhere(
        new Brackets((qb) => {
          where.forEach((wh) => {
            qb.orWhere(
              new Brackets((qb) => {
                this.applyBuildOptions({ qb, where: wh, buildWhereOptions })
              })
            )
          })
        })
      )
    } else {
      this.applyBuildOptions({ qb, where, buildWhereOptions })
    }
  }

  private applyBuildOptions<T>({
    qb,
    where,
    buildWhereOptions,
  }: {
    qb: WhereExpression
    where: T
    buildWhereOptions: BuildWhereOptionsFunction<T>
  }) {
    buildWhereOptions({
      where,
      filterQuery: (property, valueOrOperator) => {
        if (isNil(valueOrOperator)) return
        qb.andWhere(this.computeFindOperatorExpression(property, valueOrOperator))
      },
    })
  }

  /**
   * ì»¬ëŸ¼ê³¼ ë¹„êµê°’ì— ëŒ€í•œ Raw Queryë¥¼ ê³„ì‚°í•˜ì—¬ ë°˜í™˜í•´ì¤€ë‹¤. Referenced by TypeORM.
   * @param property Column ì´ë¦„
   * @param operator FindOperator ë˜ëŠ” ì§ì ‘ ê°’(Literalì€ Equalì—°ì‚°ì„ í•œë‹¤.)
   * @returns
   */
  private computeFindOperatorExpression(property: string, operator: FindOperator<any> | any) {
    const wrappedValue = (value: any) => {
      // í° ë”°ì˜´í‘œ íŒŒì‹±
      if (typeof value === 'string') return `"${value.replace(/"/g, '\\"')}"`
      else if (value instanceof Date) return `"${value.toISOString()}"`

      return value
    }

    if (!(operator instanceof FindOperator)) return `${property} = ${wrappedValue(operator)}`

    switch (operator.type) {
      case 'not':
        if (operator.child) {
          return `NOT(${this.computeFindOperatorExpression(property, operator.child)})`
        } else {
          return `${property} != ${wrappedValue(operator.value)}`
        }
      case 'lessThan':
        return `${property} < ${wrappedValue(operator.value)}`
      case 'lessThanOrEqual':
        return `${property} <= ${wrappedValue(operator.value)}`
      case 'moreThan':
        return `${property} > ${wrappedValue(operator.value)}`
      case 'moreThanOrEqual':
        return `${property} >= ${wrappedValue(operator.value)}`
      case 'equal':
        return `${property} = ${wrappedValue(operator.value)}`
      case 'like':
        return `${property} LIKE ${wrappedValue(operator.value)}`
      case 'between':
        return `${property} BETWEEN ${wrappedValue(operator.value[0])} AND ${wrappedValue(
          operator.value[1]
        )}`
      case 'in':
        if (operator.value.length === 0) {
          return '0=1'
        }
        return `${property} IN (${operator.value.map((v) => wrappedValue(v)).join(', ')})`
      case 'any':
        return `${property} = ANY(${wrappedValue(operator.value)})`
      case 'isNull':
        return `${property} IS NULL`
    }

    throw new TypeError(`Unsupported FindOperator ${FindOperator.constructor.name}`)
  }
}
```

ë¦¬íŒ©í„°ë§ëœ `AbstractEntityRepository`ë¥¼ í† ëŒ€ë¡œ `UserRepository`ë¥¼ ë‹¤ìŒê³¼ ê°™ì´ ìˆ˜ì •í•©ë‹ˆë‹¤.

```typescript
// user.repository.ts
import { EntityRepository } from 'typeorm'
import { AbstractEntityRepository, EntityFindOperator } from './entity.repository'
import { User } from './user.entity'

export interface UserFindAllWhereOptions {
  id?: EntityFindOperator<number> // export type EntityFindOperator<T> = T | FindOperator<T>
  email?: EntityFindOperator<string>
  nickname?: EntityFindOperator<string>
}

export interface UserFindAllOptions {
  where?: UserFindAllWhereOptions | UserFindAllWhereOptions[]

  skip?: number
  take?: number
}

@EntityRepository(User)
export class UserRepository extends AbstractEntityRepository<User> {
  // ...
  public async findAll(options: UserFindAllOptions = {}) {
    const { where, skip, take } = options

    const qb = this.repository
      .createQueryBuilder('User')
      .leftJoinAndSelect('User.userAuth', 'userAuth')
      .leftJoinAndSelect('User.userProfile', 'userProfile')

    this.queryApplier.apply({
      qb,
      where,
      buildWhereOptions: ({ filterQuery, where }) => {
        const { id, email, nickname } = where

        filterQuery('User.id', id) // idëŠ” FindOperatorì¼ìˆ˜ë„, ë¦¬í„°ëŸ´ ê°’ì¼ ìˆ˜ë„ ìˆìŠµë‹ˆë‹¤!
        filterQuery('User.email', email)
        filterQuery('User.nickname', nickname)
      },
    })

    qb.skip(skip ?? 0)
    qb.skip(take ?? 20)

    const [items, total] = await qb.getManyAndCount()

    return { items, total }
  }
}
```

ì´ì œ ë‹¤ ëë‚¬ìŠµë‹ˆë‹¤! ê³ ìƒ ë§ìœ¼ì…¨ìŠµë‹ˆë‹¤. ì´ì œ `UserService`ì—ì„œ ë‹¤ìŒê³¼ ê°™ì´ `Repository` ì ‘ê·¼ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

```typescript
// user.service.ts
import { Injectable } from '@nestjs/common'
import { In, LessThan } from 'typeorm'
import { UserRepository } from './user.repository'

@Injectable()
export class UserService {
  constructor(private readonly userRepository: UserRepository) {}

  // ...

  public async findAllTest() {
    // IDê°€ 5ë³´ë‹¤ ì‘ê±°ë‚˜, ë‹‰ë„¤ì„ì´ alfred, beygeeì¸ Userë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤!
    return this.userRepository.findAll({
      where: [{ id: LessThan(5) }, { nickname: In(['alfred', 'beygee']) }],
    })
  }
}
```

ì´í† ë¡ `Service`ì—ì„œëŠ” `Repository` `where` ì¡°ê±´ë¬¸ì„ ê°ì²´ í˜•íƒœë¡œ ë‚ ë¦¬ê³ , `Repo`ì—ì„œëŠ” ê·¸ ì¡°ê±´ì„ `QueryBuilder`ë¡œ ë³€í™˜í•˜ì—¬ ì‘ì—…í•˜ëŠ” ë¡œì§ì„ êµ¬í˜„í•´ë³´ì•˜ìŠµë‹ˆë‹¤.

ì•„ì§ ì—¬ê¸°ì €ê¸° ê°œì„ í•´ì•¼í•  ì‚¬í•­ë“¤ì´ ë³´ì´ê³ , ê°ˆ ê¸¸ì´ í•œì°¸ ë‚¨ì€ ê²ƒ ê°™ìŠµë‹ˆë‹¤. ë” ì¢‹ì€ êµ¬í˜„ì‚¬í•­ì´ ìˆë‹¤ë©´ ê³µìœ í•´ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤.

ë‹¤ìŒ í¬ìŠ¤íŠ¸ì—ëŠ” `Repository`ì—ì„œ ê°ì²´ì˜ ì˜ì†ì„±ì„ ë³´ì¥í•˜ë©´ì„œ ì±…ì„ ê¸°ë°˜ ì„¤ê³„`(Single Table Inheritance Pattern)`ë¥¼ í•˜ëŠ” ë²•ì„ ì‚´í´ë³´ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.
